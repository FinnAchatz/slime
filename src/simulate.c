#include "cgif.h"
#include "framework.h"
#include "gifenc.h"
#include "parameters.h"
#include "random.h"
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define INDEX(X, Y) (X + Y * SIZE_X)

/* Small helper functions to initialize GIF- and frame-configuration */
static void initGIFConfig(CGIF_Config *pConfig, char *path, uint16_t width,
                          uint16_t height, uint8_t *pPalette,
                          uint16_t numColors) {
    memset(pConfig, 0, sizeof(CGIF_Config));
    pConfig->width = width;
    pConfig->height = height;
    pConfig->pGlobalPalette = pPalette;
    pConfig->numGlobalPaletteEntries = numColors;
    pConfig->path = path;
    pConfig->attrFlags = CGIF_ATTR_IS_ANIMATED;
}
static void initFrameConfig(CGIF_FrameConfig *pConfig, uint8_t *pImageData,
                            uint16_t delay) {
    memset(pConfig, 0, sizeof(CGIF_FrameConfig));
    pConfig->delay = delay;
    pConfig->pImageData = pImageData;
}

void *init_animation() {
    /* create a GIF */
    ge_GIF *gif = ge_new_gif(
        "slime.gif",    /* file name */
        SIZE_X, SIZE_Y, /* canvas size */
        (uint8_t[]){
            /* palette */
            0xFF, 0xFF, 0xFF, // white
            0x00, 0x00, 0x00, // black
            0xFF, 0x00, 0x00, // red
            0x00, 0xFF, 0x00, // green
            0x00, 0x00, 0xFF, // blue
            0x00, 0xFF, 0xFF, // cyan
            0xFF, 0x00, 0xFF, // magenta
            0xFF, 0xFF, 0x00, // yellow

            0xFC, 0xFF, 0xFF, // teal/cyan increasing intensity [64]
            0xF8, 0xFF, 0xFF, 0xF4, 0xFF, 0xFF, 0xF0, 0xFF, 0xFF, 0xEC, 0xFF,
            0xFF, 0xE8, 0xFF, 0xFF, 0xE4, 0xFF, 0xFF, 0xE0, 0xFF, 0xFF, 0xDC,
            0xFF, 0xFF, 0xD8, 0xFF, 0xFF, 0xD4, 0xFF, 0xFF, 0xD0, 0xFF, 0xFF,
            0xCC, 0xFF, 0xFF, 0xC8, 0xFF, 0xFF, 0xC4, 0xFF, 0xFF, 0xC0, 0xFF,
            0xFF, 0xBC, 0xFF, 0xFF, 0xB8, 0xFF, 0xFF, 0xB4, 0xFF, 0xFF, 0xB0,
            0xFF, 0xFF, 0xAC, 0xFF, 0xFF, 0xA8, 0xFF, 0xFF, 0xA4, 0xFF, 0xFF,
            0xA0, 0xFF, 0xFF, 0x9C, 0xFF, 0xFF, 0x98, 0xFF, 0xFF, 0x94, 0xFF,
            0xFF, 0x90, 0xFF, 0xFF, 0x8C, 0xFF, 0xFF, 0x88, 0xFF, 0xFF, 0x84,
            0xFF, 0xFF, 0x80, 0xFF, 0xFF, 0x7C, 0xFF, 0xFF, 0x78, 0xFF, 0xFF,
            0x74, 0xFF, 0xFF, 0x70, 0xFF, 0xFF, 0x6C, 0xFF, 0xFF, 0x68, 0xFF,
            0xFF, 0x64, 0xFF, 0xFF, 0x60, 0xFF, 0xFF, 0x5C, 0xFF, 0xFF, 0x58,
            0xFF, 0xFF, 0x54, 0xFF, 0xFF, 0x50, 0xFF, 0xFF, 0x4C, 0xFF, 0xFF,
            0x48, 0xFF, 0xFF, 0x44, 0xFF, 0xFF, 0x40, 0xFF, 0xFF, 0x3C, 0xFF,
            0xFF, 0x38, 0xFF, 0xFF, 0x34, 0xFF, 0xFF, 0x30, 0xFF, 0xFF, 0x2C,
            0xFF, 0xFF, 0x28, 0xFF, 0xFF, 0x24, 0xFF, 0xFF, 0x20, 0xFF, 0xFF,
            0x1C, 0xFF, 0xFF, 0x18, 0xFF, 0xFF, 0x14, 0xFF, 0xFF, 0x10, 0xFF,
            0xFF, 0x0C, 0xFF, 0xFF, 0x08, 0xFF, 0xFF, 0x04, 0xFF, 0xFF, 0x04,
            0xFF, 0xFF,
        },
        7,  /* palette depth == log2(# of colors) */
        -1, /* no transparency */
        0   /* infinite loop */
    );
    return gif;
}

void step_animation(void *animation, uint8_t *data_map, float *trail_map, uint8_t* pImageData, CGIF_FrameConfig* fConfig, CGIF* pGIF) {
    ge_GIF *gif = animation;

    for (size_t i = 0; i < SIZE_X; i++) {
        for (size_t j = 0; j < SIZE_Y; j++) {
            // set color to trail map
            gif->frame[INDEX(i, j)] =
                TRAIL_COLOR_START +
                (int)((trail_map[INDEX(i, j)] < 64 ? trail_map[INDEX(i, j)]
                                                   : 63));
            if (data_map[INDEX(i, j)] != EMPTY_COLOR) {
                gif->frame[INDEX(i, j)] = data_map[INDEX(i, j)];
                data_map[INDEX(i, j)] = EMPTY_COLOR;
            }
        }
    }

    // initFrameConfig(fConfig, gif->frame, 10);                           // initialize the frame-configuration
    // cgif_addframe(pGIF, fConfig);                                       // append the new frame

    ge_add_frame(gif, STEP_SPEED);

    // printf("\n----------------\n");
    // for (size_t i = 0; i < SIZE_Y; i++) {
    //     for (size_t j = 0; j < SIZE_X; j++) {
    //         printf("%s", data_map[INDEX(j,i)] ? "#" : " ");
    //     }
    //     printf("\n");
    // }
    // printf("----------------\n");
}

void stop_animation(void *animation) { ge_close_gif(animation); }

void simulate() {
    CGIF *pGIF;               // struct containing the GIF
    CGIF_Config gConfig;      // global configuration parameters for the GIF
    CGIF_FrameConfig fConfig; // configuration parameters for a frame
    uint8_t *pImageData;      // image data (an array of color-indices)
    uint8_t aPalette[] = {
            /* palette */
            0xFF, 0xFF, 0xFF, // white
            0x00, 0x00, 0x00, // black
            0xFF, 0x00, 0x00, // red
            0x00, 0xFF, 0x00, // green
            0x00, 0x00, 0xFF, // blue
            0x00, 0xFF, 0xFF, // cyan
            0xFF, 0x00, 0xFF, // magenta
            0xFF, 0xFF, 0x00, // yellow

            0xFC, 0xFF, 0xFF, // teal/cyan increasing intensity [64]
            0xF8, 0xFF, 0xFF, 0xF4, 0xFF, 0xFF, 0xF0, 0xFF, 0xFF, 0xEC, 0xFF,
            0xFF, 0xE8, 0xFF, 0xFF, 0xE4, 0xFF, 0xFF, 0xE0, 0xFF, 0xFF, 0xDC,
            0xFF, 0xFF, 0xD8, 0xFF, 0xFF, 0xD4, 0xFF, 0xFF, 0xD0, 0xFF, 0xFF,
            0xCC, 0xFF, 0xFF, 0xC8, 0xFF, 0xFF, 0xC4, 0xFF, 0xFF, 0xC0, 0xFF,
            0xFF, 0xBC, 0xFF, 0xFF, 0xB8, 0xFF, 0xFF, 0xB4, 0xFF, 0xFF, 0xB0,
            0xFF, 0xFF, 0xAC, 0xFF, 0xFF, 0xA8, 0xFF, 0xFF, 0xA4, 0xFF, 0xFF,
            0xA0, 0xFF, 0xFF, 0x9C, 0xFF, 0xFF, 0x98, 0xFF, 0xFF, 0x94, 0xFF,
            0xFF, 0x90, 0xFF, 0xFF, 0x8C, 0xFF, 0xFF, 0x88, 0xFF, 0xFF, 0x84,
            0xFF, 0xFF, 0x80, 0xFF, 0xFF, 0x7C, 0xFF, 0xFF, 0x78, 0xFF, 0xFF,
            0x74, 0xFF, 0xFF, 0x70, 0xFF, 0xFF, 0x6C, 0xFF, 0xFF, 0x68, 0xFF,
            0xFF, 0x64, 0xFF, 0xFF, 0x60, 0xFF, 0xFF, 0x5C, 0xFF, 0xFF, 0x58,
            0xFF, 0xFF, 0x54, 0xFF, 0xFF, 0x50, 0xFF, 0xFF, 0x4C, 0xFF, 0xFF,
            0x48, 0xFF, 0xFF, 0x44, 0xFF, 0xFF, 0x40, 0xFF, 0xFF, 0x3C, 0xFF,
            0xFF, 0x38, 0xFF, 0xFF, 0x34, 0xFF, 0xFF, 0x30, 0xFF, 0xFF, 0x2C,
            0xFF, 0xFF, 0x28, 0xFF, 0xFF, 0x24, 0xFF, 0xFF, 0x20, 0xFF, 0xFF,
            0x1C, 0xFF, 0xFF, 0x18, 0xFF, 0xFF, 0x14, 0xFF, 0xFF, 0x10, 0xFF,
            0xFF, 0x0C, 0xFF, 0xFF, 0x08, 0xFF, 0xFF, 0x04, 0xFF, 0xFF, 0x04,
            0xFF, 0xFF,
        };
    uint16_t numColors = 72; // number of colors in aPalette (up to 256 possible)

    // initialize the GIF-configuration and create a new GIF
    initGIFConfig(&gConfig, "example_cgif.gif", SIZE_X, SIZE_Y, aPalette,
                  numColors);
    pGIF = cgif_newgif(&gConfig);

    // create image frames and add them to GIF
    pImageData = malloc(SIZE_X * SIZE_Y);                                   // allocate memory for image data

    seed((uint32_t[4]){1341, 123123, 424, 123123});

    uint8_t *data_map = malloc(sizeof(uint8_t) * SIZE_X * SIZE_Y);
    float *trail_map = malloc(sizeof(float) * SIZE_X * SIZE_Y);
    float *trail_map_buff = malloc(sizeof(float) * SIZE_X * SIZE_Y);
    agent_t *agents = malloc(sizeof(agent_t) * NUM_PARTICLES);
    float conv_map[9] = {.0025f, .01f,   .0025f, .01f,  .9f,
                         .01f,   .0025f, .01f,   .0025f};
    // float conv_map[9] = {.0,.0f,.0f,
    //                      .0f,.9f,.0f,
    //                      .0f,.0f,.0f};

    init_grid(data_map, trail_map, agents);

    void *animation = init_animation();
    step_animation(animation, data_map, trail_map, pImageData, &fConfig, pGIF);

    // main loop
    for (size_t n = 0; n < ITERATIONS; n++) {
        convolute_trails(&trail_map, &trail_map_buff, conv_map);
        for (size_t i = 0; i < NUM_PARTICLES; i++) {
            sensory_stage(trail_map, &(agents[i]));
        }
        for (size_t i = 0; i < NUM_PARTICLES; i++) {
            motor_stage(data_map, trail_map, &(agents[i]));
        }
    step_animation(animation, data_map, trail_map, pImageData, &fConfig, pGIF);
    }

    stop_animation(animation);
    // close created GIF-file and free allocated space
    cgif_close(pGIF);
    free(pImageData);                                                      // free image data when all frames are added
    free(data_map);
    free(trail_map);
    free(trail_map_buff);
    free(agents);
}

int main(void) {

    simulate();

    return EXIT_SUCCESS;
}
